# 평가 프로토콜 (Evaluation Protocol)

본 문서는 본 프로젝트의 이상탐지 평가 기준과 계산 방식을 정의합니다.

---

## 0) 용어 정의 (Terminology)

### 0.1 "Local" (로컬) 이상탐지

본 프로젝트에서 "Local" (로컬)은 **세 가지 상호연결된 의미**를 가집니다:

#### (1) 데이터/공정 특화 적응 (Data/Process-Specific Adaptation) - 주요 의미
- **정의**: 이상탐지 규칙, 임계값, 모델이 **데이터셋 또는 제조 공정마다 특화**되며, 범용(global) 모델이 아님
- **근거**: 제조 환경은 이질적 (밸브 모니터링 ≠ 모터 진동 ≠ 화학 센서)
- **구현**:
  - 공정별 비용 행렬 (FN/FP 비율이 중요도에 따라 다름)
  - 데이터셋별 임계값 (SKAB 밸브 ≠ SMD 서버 메트릭)
  - 공정 인식 특징 선택 (주기적 기계는 주파수 특징, 일시적 결함은 시간 도메인)
- **연구 함의**: RQ4 (비용 민감도)는 데이터셋 특성(불균형, SNR)에 따라 비용 행렬을 **로컬** 적응하는 방법 탐구

#### (2) 온프레미스 배포 가능성 (On-Premise Deployment Capability) - 부차 의미
- **정의**: 시스템이 **로컬(온프레미스) 인프라**에서 실행 가능, 클라우드 전용 아님
- **근거**:
  - 제조 데이터는 독점 공정 파라미터 포함 → 개인정보/지식재산 우려
  - 일부 환경은 공기 차단(air-gapped) (국방, 제약 클린룸)
  - 실시간 제약 (밀리초 지연) → 엣지/로컬 배포 선호
- **구현**:
  - **로컬 EXAONE 모델** (Phase 2): LLM이 로컬 GPU에서 실행 (`cuda:3`)
  - 모든 핵심 탐지 (Phase 1)는 Python 3.9+ 표준 라이브러리 외 **외부 의존성 없음**

#### (3) 맥락-로컬 탐지 (Context-Local Detection) - 기술적 의미
- **정의**: 이상탐지가 **로컬 시간 창 맥락**에서 작동 (포인트 단위 또는 짧은 세그먼트), 전역/집합 패턴 아님
- **기술 세부사항**:
  - **포인트 단위 이상**: 로컬 이웃 `[t-w, t+w]`을 고려한 단일 타임스탬프 `t`의 비정상 값
  - **세그먼트-로컬**: 짧은 연속 이상 (10-50 포인트의 단계 변화, 드리프트)
- **프로젝트 범위**:
  - 다음을 사용하여 **로컬** 스파이크, 단계, 드리프트 탐지:
    - 롤링 z-점수 (로컬 창=기본 50)
    - 값 공간의 kNN (로컬 밀도)
    - 주파수 대역 (로컬 STFT 창=128)
  - **탐지하지 않음**: 전역 계절 변화 또는 집합 순차 패턴

**참조**: 자세한 내용은 `docs/LOCAL_DEFINITION.md` 참조

### 0.2 포인트 단위(Point-wise) vs 이벤트 단위(Event-wise)

- **포인트 단위 지표**: 각 타임스탬프를 독립적으로 평가 (F1, Precision, Recall)
  - 장점: 정밀한 위치 평가
  - 단점: 긴 이상 이벤트에서 과도하게 엄격 (확장 탐지 처벌)

- **이벤트 단위 지표**: 연속 이상 세그먼트를 하나의 이벤트로 평가
  - 장점: 탐지 지연, 리드 타임 캡처; 제조 도메인 직관과 일치
  - 단점: 이벤트 경계에 민감

**연구 함의**: RQ3은 두 지표 간 상관관계 조사 → 약한 상관관계이면 주요 지표 선택 필요

### 0.3 보정(Calibration) vs 판별(Discrimination)

- **판별**: 이상과 정상을 **분리**하는 능력 (AUC-ROC, AUC-PR로 측정)
- **보정**: 예측 확률이 **실제 빈도**와 일치 (ECE로 측정)
  - 예: p=0.8로 예측한 100개 샘플 중 실제로 ~80개가 이상이어야 함
- **관계**: 높은 AUC이지만 잘못 보정된 탐지기 가능 → 비용 민감 임계값 설정에 부적합

**참고**: 분류의 보정에 대한 논의는 Guo et al. (2017) "On Calibration of Modern Neural Networks" 참조

---

## 1) 점수 기반 분류 지표
- Precision, Recall, F1, Accuracy: 포인트 단위 이진 분류 기준
- ROC/AUC: 점수 내림차순으로 FPR/TPR 곡선을 생성하여 면적 계산
- PR/AUC: 점수 내림차순으로 Recall/Precision 곡선을 생성하여 면적 계산

## 2) Calibration
- ECE(정의): 확률 구간(bin)별 평균 예측 확률과 실제 빈도의 차이의 가중 평균
- 방법: Isotonic(권장), Platt(보조), Temperature Scaling(표준화 점수에 대해 온도 T 최적화), 또는 Min-Max 정규화(비교용)

## 3) 비용 민감 임계(Decision)
- 비용행렬: (C00, C01, C10, C11) = (TN, FP, FN, TP)
- 기대비용: (TN*C00 + FP*C01 + FN*C10 + TP*C11) / N
- 최적 임계: 점수의 유일한 값 사이 중간점 및 경계 포함 후보에서 기대비용이 최소인 임계 선택
- 보고: fixed vs optimal 기대비용 및 기대 이득(gain)
- 선택 옵션: "적용" 모드에서 최적 임계를 실제 예측 생성에 반영하여 A/B 비교 보고

## 4) 시계열 특화 지표 (정의)
기호:
- 시계열 길이 N, 시점 t=0..N-1
- 이진 라벨 y[t]∈{0,1}
- 예측 p[t]∈{0,1} (임계 적용 후)
- 이벤트 구간 S_k=[s_k, e_k]는 연속한 1들의 최대 구간(라벨 기반)

4.1 Detection Delay (지연)
- 각 이벤트 S_k에 대해 최초 탐지 시점 τ_k = min{ t∈S_k ∪ {e_k+1} | p[t]=1 } (구간 내 첫 탐지, 없으면 e_k+1로 간주)
- Delay_k = max(0, τ_k - s_k)
- 보고: 평균/중앙값 등 요약 통계

4.2 Lead Time (리드 타임)
- 사전 정의된 피크/임계 시점 h_k(예: S_k의 중앙값 또는 도메인 정의 임계 시점)
- Lead_k = max(0, h_k - τ_k) (τ_k ≤ h_k일 때 선행 시간)
- 보고: 평균/중앙값
  (현 구현 주석) 초기 구현에서는 h_k를 이벤트 구간의 끝점 e_k로 근사하여 계산합니다.

4.3 Point-Adjust (이벤트 기반 조정 정확도)
- 규칙: 이벤트 구간 S_k에서 한 번이라도 p[t]=1이면 해당 구간을 TP로 간주, 아니면 FN
- 비이벤트(배경) 구간에서 p[t]=1이면 FP, 아니면 TN
- 이벤트 단위 지표: Precision_event = TP/(TP+FP), Recall_event = TP/(TP+FN), F1_event = 2PR/(P+R)

구현 메모:
- 본 저장소의 `experiments/metrics.py`는 구간 추출 및 이벤트 F1/Delay/Lead 계산 유틸을 포함합니다.
- Delay/Lead Time은 현 구현(끝점 근사)을 시작점으로, 다음 루프에서 도메인 정의 피크 기반으로 확대합니다.

## 5) 재현성
- seed, run_id, git_sha, start_ts를 run.json에 항상 기록
- 동일 설정에서 AUC(ROC/PR) 변화는 ±1e-6 이내

## 6) 보고
- 단건: 실행 폴더 REPORT.md(핵심 지표/비용 임계/A-B 비교/아티팩트 경로)
- 배치: runs/reports/<UTC>/summary.csv, REPORT.md에 평균/분산/개요 수록(추가)

## 7) 데이터 분할 규약 (SMD)
- SMD는 공식 split을 준수: train/test는 경로 기준으로 구분하며, `test_label`은 test에만 적용
- 길이 불일치 시 잘라서 맞춤 또는 0 padding 처리(본 로더 구현과 동일)
